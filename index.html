<!DOCTYPE html>
<html lang="de" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>Mandelbrot</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.1/p5.min.js"></script>
    <style>
    * {
        margin: 0;
        padding: 0;
    }

    canvas {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        box-shadow: 0px 0px 50px #e6e6e6;
    }
    </style>
  </head>
  <body>
    <script>
    // Weitere Features
    // Farben (Farben anpassen und besser darstellen)
    // Grenze vom Benutzer einstellen lassen (Aktuell 2)
    // Schwellenwert vom Benutzer einstellen lassen (Aktuell 100)
    // Intervalle der gauss'schen Zahlenebene anpassen
    // Export als PNG

    // Variablen
    var reMin = -2; // Koordinatenachse: Realteil Minimum
    var reMax = 1; // Koordinatenachse: Realteil Maximumg
    var imMin = -1; // Koordinatenachse: Imaginärteil Minimum
    var imMax = 1; // Koordinatenachse: Imaginärteil Maximum

    var zoomBoxSize, zoomOutX, zoomOutY, zoomInX, zoomInY, customZoomXStart, customZoomXEnd, customZoomYStart, customZoomYend; // Zoom Variablen
    var settingsBoxSize, settingsX, settingsY, settingsBoxRadius; // Einstellungen Variablen
    var cache = []; // Cache-Variable für Mandelbrotmengen 

    // Setupfunction von p5JS
    function setup() {
      // Zeige canvas
      createCanvas(600, 400);

      // Intialisiere Zoomvariablen
      zoomBoxSize = 20;
      zoomOutX = width - 55;
      zoomOutY = height - 30;
      zoomInX = width - 30;
      zoomInY = height - 30;
      customZoomXStart = 0;
      customZoomYStart = 0;
      customZoomXEnd = 0;
      customZoomYEnd = 0;
      settingsBoxSize = zoomBoxSize;
      settingsX = width - 30;
      settingsY = 10;
      settingsBoxRadius = 3;
    }

    // Drawfunction von p5JS
    function draw() {
      // Hintergrundfarbe setzen
      background("white");

      // Umrechnung von Pixel in das kartesische Koordinatensystem
      let lengthPerPx = Math.abs(reMax - reMin) / width;
      let heightPerPx = Math.abs(imMax - imMin) / height;

      // Chache prüfen
      if(cache.reMin != reMin ||
        cache.reMax != reMax ||
        cache.imMin != imMin ||
        cache.imMax != imMax) {
        // Cache löschen und neu befüllen
        cache.reMin = reMin;
        cache.reMax = reMax;
        cache.imMin = imMin;
        cache.imMax = imMax;
        cache.mandelbrotmenge = [];
        cache.nichtmandelbrotmenge = [];

        // Mandelbrotmenge suchen
        for (let y = 0; y < height; y++) { // Imaginärteil durchlaufen von oben nach unten
          for (let x = 0; x < width; x++) { // Realteil durchlaufen von links nach rechts
            let c = [(reMin + lengthPerPx * x), (imMax - heightPerPx * y)]; // Komplexe Zahl [re, im]

            // Prüfen ob in Mandelbrotmenge
            let trialsForMandelbrot = isPartOfMadelbrotSet(c);
            if (trialsForMandelbrot === true) {
              cache.mandelbrotmenge.push([x,y]);
            }else {
              cache.nichtmandelbrotmenge.push([x,y,trialsForMandelbrot]);
            }
          }
        }
      }

      // Mandelbrotmenge anzeigen
      for(let i = 0; i < cache.mandelbrotmenge.length; i++) {
        stroke('black'); // Punkte einfärben
        strokeWeight(1); // Grösse der Punkte definieren
        point(cache.mandelbrotmenge[i][0], cache.mandelbrotmenge[i][1]); // Punkt anzeigen
      }

      // Nicht Mandelbrotmenge anzeigen
      for(let i = 0; i < cache.nichtmandelbrotmenge.length; i++) {
        let x = (255-((cache.nichtmandelbrotmenge[i][2]-1)/100*250));
        // stroke(x, 255-x*0.01, 0); // Punkte einfärben zwischen Gelb und Grün
        stroke(255-x*0.01, 255-x, x); // Punkte einfärben zwischen Gelb und Pink
        strokeWeight(2); // Grösse der Punkte definieren
        point(cache.nichtmandelbrotmenge[i][0], cache.nichtmandelbrotmenge[i][1]); // Punkt anzeigen
      }

      // Koordinatensystem
      let re = map(0, imMin, imMax, height, 0); // x-Achse
      let im = map(0, reMin, reMax, 0, width); // y-Achse

      stroke('black'); // Koordinatenachsen einfärben<
      line(0, re, width, re); // Reelle Koordinatenachse
      line(im, 0, im, height); // Imaginäre Koordinatenachse

      let reLength = Math.abs(reMax - reMin); // Länge vom realteil berechnen
      let imLength = Math.abs(imMax - imMin); // Länge vom imaginärteil berechnen

      // Koordinatenachsenbeschriftung
      let xAxisElements = 5; // Anzal Markierungen auf der X-Achse
      let yAxisElements = 4; // Anzal Markierungen auf der Y-Achse
      let xAxisElementsLength = (reLength/(xAxisElements+1)).toExponential(1); // Abstand zwischen den Markierungen
      let yAxisElementsLength = (imLength/(yAxisElements+1)).toExponential(1); // Abstand zwischen den Markierungen


      for(let i = 0; i <= Math.max(xAxisElements, yAxisElements) + 1; i++) {
        // Werte berechnen
        let reOffset = Math.abs(reMin)%xAxisElementsLength;
        let imOffset = Math.abs(imMax)%yAxisElementsLength;
        let rePoint = reMin + xAxisElementsLength*i + reOffset; // Markierungsposition berechnen (Anzeige)
        let imPoint = imMax - yAxisElementsLength*i - imOffset; // Markierungsposition berechnen (Anzeige)
        let rePointCanvas = width/reLength*Math.abs(reMin-rePoint); // Markierungsposition auf der Canvas berechnen
        let imPointCanvas = height/imLength*Math.abs(imMax-imPoint); // Markierungsposition auf der Canvas berechnen

        // Beschriftung und Line der reellen Koordinatenachse
        textSize(10);
        if(re < 0) {
          // Fixiere die reelle Koordinatenachse oben
          fill("black");
          stroke("white");
          textAlign(CENTER, CENTER);
          text(rePoint.toPrecision(2), rePointCanvas, 10); // Realteil
          textAlign(LEFT, CENTER);
          text('Re(Z)', 5, 10); // Einheit
          stroke("black");
          line(rePointCanvas, 0, rePointCanvas, 3); // Markierungslinie
        }else if(re > height) {
          // Fixiere die reelle Koordinatenachse unten
          fill("black");
          stroke("white");
          textAlign(CENTER, BOTTOM);
          text(rePoint.toPrecision(2), rePointCanvas, height - 10); // Realteil
          textAlign(LEFT, BOTTOM);
          text('Re(Z)', 5, height - 25); // Einheit
          stroke("black");
          line(rePointCanvas, height, rePointCanvas, height - 3); // Markierungslinie
        }else {
          // Standarddarstellung der reelle Koordinatenachse
          fill("black");
          stroke("white");
          textAlign(CENTER, CENTER);
          text(rePoint.toPrecision(2), rePointCanvas, re - 10); // Realteil
          textAlign(LEFT, CENTER);
          text('Re(Z)', 5, re + 10); // Einheit
          stroke("black");
          line(rePointCanvas, re - 3, rePointCanvas, re + 3); // Markierungslinie
        }

        // Beschriftung und Line der komplexen Koordinatenachse
        textSize(10);
        if(im < 0) {
          // Fixiere die komplexe Koordinatenachse links
          fill("black");
          stroke("white");
          textAlign(LEFT, CENTER);
          text(imPoint.toPrecision(2), 10, imPointCanvas); // Imaginärteil
          textAlign(LEFT, TOP);
          text('Im(Z)', 5, 20); // Einheit
          stroke("black");
          line(0, imPointCanvas, 3, imPointCanvas); // Markierungslinie
        }else if(im > width) {
          // Fixiere die komplexe Koordinatenachse recht
          fill("black");
          stroke("white");
          textAlign(RIGHT, CENTER);
          text(imPoint.toPrecision(2), width - 10, imPointCanvas); // Imaginärteil
          textAlign(RIGHT, TOP);
          text('Im(Z)', width - 10, 40); // Einheit
          stroke("black");
          line(width, imPointCanvas, width - 3, imPointCanvas); // Markierungslinie
        }else {
          // Standarddarstellung der komplexen Koordinatenachse
          fill("black");
          stroke("white");
          textAlign(LEFT, CENTER);
          text(imPoint.toPrecision(2), im + 10, imPointCanvas); // Imaginärteil
          textAlign(RIGHT, TOP);
          text('Im(Z)', im - 10, 5); // Einheit
          stroke("black");
          line(im - 3, imPointCanvas, im + 3, imPointCanvas); // Markierungslinie
        }
      }



      // Einstellungen
      fill("black");
      strokeWeight(0);
      rect(settingsX, settingsY, settingsBoxSize, settingsBoxSize, settingsBoxRadius, settingsBoxRadius, settingsBoxRadius, settingsBoxRadius);
      fill("white");
      textSize(settingsBoxSize*2/3);
      textAlign(CENTER, CENTER);
      text("⚙️", settingsX, settingsY, settingsBoxSize, settingsBoxSize); // Text für zoom out

      // Zoom Button anzeigen
      fill("black");
      strokeWeight(0);
      rect(zoomOutX, zoomOutY, zoomBoxSize, zoomBoxSize); // Zoom out Button
      strokeWeight(0);
      rect(zoomInX, zoomInY, zoomBoxSize, zoomBoxSize); // Zoom in Button

      fill("white");
      textSize(zoomBoxSize);
      textAlign(CENTER, CENTER);
      text("-", zoomOutX, zoomOutY, zoomBoxSize, zoomBoxSize); // Text für zoom out
      textSize(zoomBoxSize);
      textAlign(CENTER, CENTER);
      text("+", zoomInX, zoomInY, zoomBoxSize, zoomBoxSize); // Text für zoom in

      if (mouseIsPressed == true) {
        // Zoom prüfen
        if(mouseX > zoomOutX && mouseX < (zoomOutX + zoomBoxSize) && // X-Achse
           mouseY > zoomOutY && mouseY < (zoomOutY + zoomBoxSize) // Y-Achse
          ) { // Zoom out
          zoom("out"); // Herauszoomen
        }else if(mouseX > zoomInX && mouseX < (zoomInX + zoomBoxSize) && // X-Achse
                 mouseY > zoomInY && mouseY < (zoomInY + zoomBoxSize)
                ) { // Zoom in
          zoom("in"); // Hineinzoomen
        } else {
          // Eigene Auswahl treffen
          if(customZoomXStart == 0 || customZoomYStart == 0) {
            // Initialisierungsschritt
            customZoomXStart = mouseX;
            customZoomYStart = mouseY;
          }

          // Definiere Ende fortlaufend
          customZoomXEnd = mouseX;
          customZoomYEnd = mouseY;

          // Zeige Vorschau an
          stroke("black"); // Randfarbe
          strokeWeight(3); // Rand genügend dick
          fill(255,255,255,0); // transparent
          rect(customZoomXStart, customZoomYStart, mouseX - customZoomXStart, mouseY - customZoomYStart); // Rechteck für Auswahl
        }
      }else {
        // Prüfe ob Zoom benötigt
        if(customZoomXStart != 0 && customZoomYStart != 0 && customZoomXEnd != 0 && customZoomYEnd != 0 &&
          customZoomXStart != customZoomXEnd && customZoomYStart != customZoomYEnd) {
          // Die Länge muss zwingend vor dem Anpassen ausgerechnet werden, da die Koordinatenvariablen anschliessend angepasst werden
          let reLength = reMax - reMin; // Länge vom realteil berechnen
          let imLength = imMax - imMin; // Länge vom imaginärteil berechnen

          reMin += Math.min(customZoomXStart, customZoomXEnd)/width*reLength; // Neues Minimum berechnen [Zoom]
          reMax -= (width - Math.max(customZoomXStart, customZoomXEnd))/width*reLength; // Neues Maximum berechnen [Zoom]
          imMin += (height - Math.max(customZoomYStart, customZoomYEnd))/height*imLength; // Neues Minimum berechnen [Zoom]
          imMax -= Math.min(customZoomYStart, customZoomYEnd)/height*imLength; // Neues Maximum berechnen [Zoom]

          // Reset Variablen
          customZoomXStart = 0;
          customZoomYStart = 0;
          customZoomXEnd = 0;
          customZoomYEnd = 0;
        }
      }
    }

    // Mouswheelfunction von p5js
    function mouseWheel(e) {
      if(e.delta < 0) { // e.delta kann positiv oder negativ sein.
        // Die Länge muss zwingend vor dem Anpassen ausgerechnet werden, da die Koordinatenvariablen anschliessend angepasst werden
        let reLength = Math.abs(reMax - reMin); // Länge vom realteil berechnen
        let imLength = Math.abs(imMax - imMin); // Länge vom imaginärteil berechnen
        let reCenter = reMin + mouseX/width*reLength; // Neuer Mittelpunkt auf der Canvas vom realteil berechnen
        let imCenter = imMax - mouseY/height*imLength; // Neuer Mittelpunkt auf der Canvas von imaginärteil berechnen
        console.log(reCenter, reLength, reCenter - reLength/2);

        reMin = (reCenter - reLength/2)*0.9; // Neue Achsenabschnitte definieren und multiplizieren um hinein zu zoomen
        reMax = (reCenter + reLength/2)*0.9; // Neue Achsenabschnitte definieren und multiplizieren um hinein zu zoomen
        imMin = (imCenter - imLength/2)*0.9; // Neue Achsenabschnitte definieren und multiplizieren um hinein zu zoomen
        imMax = (imCenter + imLength/2)*0.9; // Neue Achsenabschnitte definieren und multiplizieren um hinein zu zoomen
      }else {
        // Die Länge muss zwingend vor dem Anpassen ausgerechnet werden, da die Koordinatenvariablen anschliessend angepasst werden
        let reLength = Math.abs(reMax - reMin); // Länge vom realteil berechnen
        let imLength = Math.abs(imMax - imMin); // Länge vom imaginärteil berechnen
        let reCenter = reMin + mouseX/width*reLength; // Neuer Mittelpunkt auf der Canvas vom realteil berechnen
        let imCenter = imMax - mouseY/height*imLength; // Neuer Mittelpunkt auf der Canvas von imaginärteil berechnen

        reMin = (reCenter - reLength/2)*1.1; // Neue Achsenabschnitte definieren und multiplizieren um hinaus zu zoomen
        reMax = (reCenter + reLength/2)*1.1; // Neue Achsenabschnitte definieren und multiplizieren um hinaus zu zoomen
        imMin = (imCenter - imLength/2)*1.1; // Neue Achsenabschnitte definieren und multiplizieren um hinaus zu zoomen
        imMax = (imCenter + imLength/2)*1.1; // Neue Achsenabschnitte definieren und multiplizieren um hinaus zu zoomen
      }
    }

    // KeyPressedfunction von p5JS
    function keyPressed() {
      // Die Länge muss zwingend vor dem Anpassen ausgerechnet werden, da die Koordinatenvariablen anschliessend angepasst werden
      let reLength = Math.abs(reMax - reMin); // Länge vom realteil berechnen
      let imLength = Math.abs(imMax - imMin); // Länge vom imaginärteil berechnen

      // Navigiere das Mandelbrot in der Canvas
      switch(keyCode) {
        case LEFT_ARROW:
          // Mandelbrot nach links verschieben
          reMin -= reLength*0.1;
          reMax -= reLength*0.1;
        break;
        case RIGHT_ARROW:
          // Mandelbrot nach rechts verschieben
          reMin += reLength*0.1;
          reMax += reLength*0.1;
        break;
        case UP_ARROW:
          // Mandelbrot nach oben verschieben
          imMin += imLength*0.1;
          imMax += imLength*0.1;
        break;
        case DOWN_ARROW:
          // mandelbrot nach unten verschieben
          imMin -= imLength*0.1;
          imMax -= imLength*0.1;
        break;
      }
    }

    // Prüfen, ob Zahl in Mandelbrotmenge ist
    // c = [re, im]
    function isPartOfMadelbrotSet(c) {
      // Mandelbrotmenge: (z[n] = z[n-1]^2+c und c = z[1])
      let z = []; // Werteliste der Mandelbrotfolge
      z[1] = c; // Startwert hinzufügen

      for (var i = 0; i < 100; i++) { // Wie Schwellenwert berechnen?
        // Berechne jedes Folgeglied bis Folgeglied 100 erreucht oder der Betrag der komplexen Zahl
        // kleiner ist als 2.
        // var quadrat = squareComplexNumber(z[i-1]);
        // var summe = addComplexNumber(quadrat, z1)
        z[i + 2] = addComplexNumber(squareComplexNumber(z[i + 1]), c);

        // Prüfe ob die Zahl zur Mandelbrotmenge gehört
        if (absoluteValue(z[i + 2]) > 2) {
          // Zahl gehört nicht zur Mandelbrotmenge.
          return i; // Anzahl Glieder zurückgeben.
        }
      }
      return true; // Zahl gehört zur Mandelbrotmenge
    }

    // Quadrat der imaginären Zahl
    // c = [re, im]
    function squareComplexNumber(c) {
      // [a,b]
      // (a+bi)^2
      // (a+bi)(a+bi)
      // a^2+2abi+bi^2
      // a^2+2abi-b^2
      // re: a^2-b^2
      // im: 2abi
      return [(c[0] ** 2 - c[1] ** 2), (2 * c[0] * c[1])]; // [re, im]
    }

    // Addition von komplexen Zahlen
    // c1 = [re, im], c2 = [re, im]
    function addComplexNumber(c1, c2) {
      // [a,b]+[c,d]
      // re: a+c
      // im: b+d
      return [(c1[0] + c2[0]), (c1[1] + c2[1])]; // [re, im]
    }

    // Betrag einer komplexen Zahl
    // c = [re, im]
    function absoluteValue(c) {
      // Math.abs(a,b) = Math.sqrt(a^2+b^2)
      return Math.sqrt(c[0] ** 2 + c[1] ** 2); // [re, im]
    }

    // Zoomt in das Mandelbrot hinein oder hinaus; Wird über einen Knopf auf Wunsch des Benutzers ausgeführt
    // direction kann entweder in oder out sein
    function zoom(direction = "in") {
      // Definiere multiplikator
      if(direction == "in") {
        var mult = 0.9; // Multiplikator um hinein zu zoomen
      }else {
        var mult = 1.9; // Multiplikator für hinaus zu zoomen
      }

      // Ersetze die Werte der aktuellen Koordinatenachsen
      reMin *= mult; // Realteil Minimum
      reMax *= mult; // Realteil Maximum
      imMin *= mult; // Imaginärteil Minimum
      imMax *= mult; // Imaginärteil Maximum
    }
    </script>
  </body>
</html>
